
# 3D Printer Queue Functionality

## Suggestions for thinking about the following feature implementation
* This is a prototype phase, we want to implement just the features for a minimum viable product. Do not create unnecessary features.
* If it seems like there is a critical missing piece of functionality, mention it!
* Be pragmatic in implementions. Don't worry about things like pagination that will be important for later phases.
* Do what is necessary to prevent injection attacks
* Make sure all errors are reported via the appropriate UI and logged to the server output.
* The db will follow an additive approach avoiding deletes wherever possible. isEnabled flags will suffice for deletes.
* Getting optimal db indexes is not critical at this phase.
* input fields and apis should impose reasonable length limits (250 char for text fields)
* Where file transfers are being handled a maximum file size of 10mb should be enforced
* Each section below will talk about functionality grouped around a concept that requires db tables, api functions and UI
* All created pages and web forms should have consistent styling with other pages and forms of the site (use of global css is preferred)

## "Named Geometry Designs" (DB table name: "NamedGeometry)

* "Named Geometry Designs" refers to a number of predefined parametric 3D models that require specific input parameters ("Geometry Input Parameters") to properly generate geometry at some later time. There will be named 3D printed designs catologed in a database table called "NamedGeometry". Each design will have a "GeometryAlgorithmName" that will be used to process the associated geometry input parameter data correctly. Each design will have a json schema saved that describes the required geometry input parameters that will be collected (in another db table), we will call this json schema field, "GeometryInputParameterSchema". Each record will also have a "GeometryID" to be referenced by other tables. "Named Geometry Designs" will be administered only by users of type system_admin, but the data will be referenced by other data visible to all users.

* GeometryInputParameterSchema json schema field data (json to be stored in db field described below):
  * See schema defined in: src/schemas/geometry-input-parameter-schema.json
  * 0 to many member list of:
    * "InputName" - a text field that allows the user to name the geometry parameter. Only the characters [0-9] and [a-z] are allowed
    * "InputDescription" - A text field that captures a description for describing this input parameter
    * "InputType" - a select field that allows choosing "Float", "Integer" or "Text" to specify the data type to be collected for this geometry parameter
    * "TextMinLen" - The minimum number of characters allowed for a Text InputType geometry parameter
    * "TextMaxLen" - The maximum number of characters allowed for a Text InputType geometry parameter
    * "NumberMin" - The minimum float value for an Integer or Float InputType geometry parameter
    * "NumberMax" - The maximum float value for an Integer or Float InputType geometry parameter
 
* Likely fields in NamedGeometry table:
  * id - autogenerated record id
  * GeometryName - String with a descriptive name for the geometry
  * GeometryAlgorithmName - String with no spaces describing the specific process that will be used to process the input parameter data that will be part of another table
  * GeometryInputParameterSchema - (as defined in: src/schemas/geometry-input-parameter-schema.json) a json schema document that will describe the list acceptable input parameter data associated with a print queue entry (described in a separate table). The entries expected in this schema have been previously described.
  * CreationTime field captureing the timestamp when this entry was created
  * CreatorID - reference to User id of the creator of this record

* Tips on seed data for NamedGeometry
  * GeometryName - "Infinity Splint 250904"
  * GeometryAlgorithName - "infinity_splint_generator_250904"
  * CreatorID - whatever the first admin user's id is
  * GeometryInputParameterSchema - based on these fields:
    * 0
      * InputName - "inter-phalange-distance-mm"
      * InputDescription - "Inter-Phalange Distance (mm) - Measure from midpoint to midpoint of the phalange's to be spanned by the splint"
      * InputType - "Float"
      * TextMinLen - 
      * TextMaxLen - 
      * NumberMin - "25.0"
      * NumberMax - "60.0"
    * 1
      * InputName - "root-circumference-mm"
      * InputDescription - "Circumference (mm) at the midpoint of the splinted phalange closest to the metacarpus"
      * InputType - "Float"
      * TextMinLen - 
      * TextMaxLen - 
      * NumberMin - "25.0"
      * NumberMax - "100.0"
    * 2
      * InputName - "mid-circumference-mm"
      * InputDescription - "Circumference (mm) at the joint to be surrounded by the splint
      * InputType - "Float"
      * TextMinLen - 
      * TextMaxLen - 
      * NumberMin - "25.0"
      * NumberMax - "100.0"
    * 3
      * InputName - "tip-circumference-mm"
      * InputDescription - "Circumference (mm) at the midpoint of the splinted phalange closest to the finger tip
      * InputType - "Float"
      * TextMinLen - 
      * TextMaxLen - 
      * NumberMin - "25.0"
      * NumberMax - "100.0"
    * 4
      * InputName - "flexion-degrees"
      * InputDescription - "Angle (degrees) of the desired bend in the splinted joint
      * InputType - "Float"
      * TextMinLen - 
      * TextMaxLen - 
      * NumberMin - "0.0"
      * NumberMax - "45.0"

* Web pages necessary for NamedGeometry data
  * "Named Geometry List" view page
    * There will need to be a web form called "Named Geometry List" that allows only users of type system_admin to view the NamedGeometry entries (GeometryInputParameterSchema can be a link that pops up a modal showing the schema text). There should be a link or button next to each row that will allow editing a single entry.
  * "Named Geometry Edit" web form edit page
    * The "Named Geometry Edit" form will allow editing the Geometry Name (db column "GeometryName"), the GeometryAlgorithmName and an expandable list fields related to each geometry input parameter that will be described in the "GeometryInputParameterSchema". The complexity that will need to be paid attention to is the part of the form that edits the GeometryInputParameterSchema. There could zero input parameters described for a specific GeometryAlgorithmName. The form will need to take into account adding and removing geometry input parameters. When the form is submitted the rows of described input parameters will need to be transformed into json schema text to be submitted to the api. When the form is loaded form field rows will need to be created and populated to match the json schema that comes from the api.

* API needed for NamedGeometry data
  * NamedGeometry data is only editable by system_admin users
  * The minimal CRUD functions

## API Key System for external system's access to the GeometryProcessingQueue (and possibly other parts later)

* The API Key system will provide secure authentication for external Geometry Processing software to interact with the GeometryProcessingQueue without requiring user credentials. This system will use Bearer token authentication with scoped permissions to ensure external systems only have access to the specific endpoints they need.

* Likely fields in ApiKey table:
  * id - autogenerated record id
  * name - String descriptive name for the API key (e.g., "Geometry Processor v1.2")
  * keyHash - String bcrypt hash of the actual API key (never store plain text)
  * permissions - JSON array of permission strings (e.g., ["geometry-queue:read", "geometry-queue:write", "print-queue:create"])
  * organizationId - Optional reference to Organization id for scoping access to specific organization data, null value indicates access to all organizations
  * isActive - Boolean flag to enable/disable the key without deletion
  * lastUsedAt - Timestamp of last successful authentication (null if never used)
  * createdAt - Timestamp when the API key was created
  * createdBy - Reference to User id who created this API key

* Authentication flow:
  * External systems send requests with `Authorization: Bearer <api-key>` header
  * Middleware validates the key hash and checks permissions for the requested endpoint
  * If valid, the request proceeds with the API key's organizational context
  * All API calls are logged with the API key identifier for audit trails

* API endpoints for API Key management:
  * Only accessible by SYSTEM_ADMIN users
  * Basic CRUD operations for creating, listing, and revoking API keys
  * Generate new API keys with configurable permissions and expiration

* Web pages necessary for API Key management:
  * "API Keys List" view page - Displays all API keys with their name, permissions, organization, status (active/inactive), last used timestamp, and creation date. Shows masked key values for security. Includes action buttons for edit/disable/delete operations.
  * "Create/Edit API Key" form page - Allows creating new API keys or editing existing ones. Form includes:
    * Name field (descriptive identifier)
    * Organization selector (dropdown of available organizations, empty value is ok)
    * Permissions checkboxes (grouped by category: geometry-queue, print-queue, etc.)
    * Active/Inactive toggle
    * When creating new keys, displays the generated API key once (with copy-to-clipboard functionality and security warning that it won't be shown again)
    * Edit mode shows key creation date and last used date but never reveals the actual key value

## Geometry Processing Queue (DB table name: "GeometryProcessingQueue")

* The GeometryProcessingQueue table will capture user submitted data related to specific form submissions that request a 3D print of the types described in the "NamedGeometry" file. The data captured here is not ready to be directly printed, but will be picked up by geometry processing software that takes the data here and processes it into ready to print files that will be in the later described PrintQueue table.

* Likely fields in GeometryProcessingQueue table:
  * id - autogenerated record id
  * GeometryID  references "id" from table NamedGeometry. Not null.
  * CreatorID references "id" from table User. Not null. This captures the user id of the user who created this geometry processing queue item.
  * OwningOrganizationID referring to "id" from table Organization. Not null. Any user that is part of this organization can view or edit this geometry processing queue item.
  * CreationTime field capturing the timestamp when this entry was created.
  * GeometryInputParameterData - This is json data that conforms to the GeometryInputParameterSchema in table NamedGeometry that corresponds to this record's selected GeometryID
  * ProcessStartedTime - timestamp for when a process run was first attempted. Null by default
  * ProcessCompletedTime - timestamp for when a process run was finished. Null by default
  * isProcessSuccessful - boolean value indicating a successful processing of the geometry. False by default.
  * isEnabled - boolean value indicating that this job should be processed if appropriate. True by default. A false indicates that the geometry processing sofware will not process this record.
  * CustomerNote - An open ended spot for user to write notes about the end custmer that should receive the 3D printed end product. Can be long 500 characters
  * CustomerID - An open ended text identifier for the end customer that should receive the 3D printed end product. This CustomerID does not reference anything else in this system. Should be short 20 characters
  * GeometryFileContents - (Null by default) A mesh file (stl or obj or 3mf)
  * GeometryFileName - (Null by default) The string name associated with the geometry file
  * PrintFileContents - (Null by default) A print file (a 3mf containing gcode)
  * PrintFileName - (Null by default) The string name associated with this print file

* Web pages necessary for GeometryProcessingQueue data:
  * "Geometry Processing Queue List" view page. Displays the list of geometry processing queue records for the current user's organization owned GeometryProcessingQueue entries. This list should by default show all geometry processing jobs that have not been successfully processed. 
  * "Create/Edit Geometry Processing Job" a web form that allows editing an existing geometry processing  job (record in GeometryProcessingQueue) or creating a new geometry processing  job. The form will allow normal editing of the fields in the GeometryProcessingQueue table (id is visible, but not editable) 
    * GeometryID will be presented to the user as a list of GeometryName values from table NamedGeometry. Users will select the nicely readable GeometryName values, but the id associated with the GeometryName will be was is saved in GeometryID
    * The part of this to pay the most attention to will be collecting the GeometryInputParameterData which is json data that conforms to the GeometryInputParameterSchema referenced by the selected GeometryID. When the form is loaded form fields will need to be created and populated as necessary for the provided json data. When the form is submitted these fields will need to be converted into json to be sent via the api.
    * GeometryFileContents, GeometryFileName, PrintFileContents, and PrintFileName will not currently be user editable, but they should be visible and users should be able to download the files when present. These files will normally be provided by an external process (splint_geo_processor). 

* API needed for GeometryProcessingQueue:
  * API functions need to validate that users/proceses interacting with the API must be part of the organization that the record is associated with. Both user sessions and the API Key system will be used for authorization.
  * The API will have functions to serve the requirements of the web pages described above. More specifically, the api will also have these functions to support the external splint_geo_processor requirements:
    * getNextGeometryJob - the splint_geo_processor will request the next job that needs to be processed. The oldest Job that does not have a ProcessStartedTime and isEnabled is true.
    * reportGeometryResult - the splint_geo_processor will report the results of processing a job. isProcessSuccessful and ProcessCompletedTime will be recorded. This function will also receive the resulting files from the splint_geo_processor when processing is successful. Upon a successful geometry processing result, a new and associated entry should be created in the PrintQueue (described below) that indicates that a job is ready to be 3D printed.

## Print Queue (DB table name: "PrintQueue")

* The PrintQueue table will be populated with data that results from successful responses to the GeometryProcessingQueue. The print queue items will be displayed via web pages a 

* Likely fields in the db table PrintQueue
  * id - autogenerated record id
  * GeometryProcessingQueueID - references the associated GeometryProcessingQueue id where the actual file data is stored.
  * PrintStartedTime - timestamp for when a print was first attempted. Null by default
  * PrintCompletedTime - timestamp for when a print was finished. Null by default
  * isPrintSuccessful - boolean value indicating a successful processing of the geometry. False by default.
  * printNote - optional String for users to report some descriptive text about the print. 255 character max.
  * isEnabled - True by default. Flag for soft deleting the entry
  * CreationTime - field capturing the timestamp when this entry was created.

* Web pages necessary for PrintQueue data:
  * "Print Queue List" view page. 
    * Displays the list of print queue records for the current user's organization owned PrintQueue entries. This list should by default show all print jobs that have not been successfully printed. Users should be able to set isPrintSuccessful for records that have a non-null PrintCompletedTime. This page will be shown and will be the most important part of the Electronjs app's view (but will also be available to the normal web version of the site). 
    * When being accessed via the ElectronJs client, there will be a "Print" button next to each row that allows the starting of an actual print. The non-ElectronJS version will not show Print buttons
    * The print buttons will interact with the local 3D printer api provided by the ElectronJS based sprint_client project.
  * "Print Queue History" view page. Displays the most recent print jobs first and has a paginated view of all print jobs. It will be possible to reprint a historical print job. When reprinting based on an old entry, a new PrintQueue record will be created referencing the same GeometryProcessingQueueID as the original PrintQueue entry.

* API needed for PrintQueue:
  * API functions need to validate that users/proceses interacting with the API must be part of the organization that the record is associated with. Both user sessions and the API Key system will be used for authorization.
  * The API will have functions to serve the requirements of the web pages described above. More specifically, the api will also have these functions to support the external splint_geo_processor requirements:
    * getOpenPrintJobs - These are print jobs that still need to be printed.
    * reportPrintResult - Reports the print completion result: PrintCompletedTime
    * reportAcceptance - Reports the user's acceptance of the completed print. This means they have inspected the printed object and have decided it is good.
    * getHistoricalPrintJobs - Pagination aware list of print jobs ordered by newest first (by CreationTime)